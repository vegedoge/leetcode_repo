# 动态规划

## 1. 概念

相比于贪心算法 DP每次的状态是由上个状态推导出来的，而贪心是局部最优解  
基础学习步骤：
+ 确定dp数组和意义
+ 确定递推公式
+ dp数组初始化
+ 确定遍历顺序
+ 推导dp数组

## 2. 例题推导

### 2.1 斐波那契

No.509
+ 确定dp数组： dp[i]第i个数
+ 递推公式：dp[i] = dp[i-1] + dp[i-2]
+ 初始化：dp[0]=0, dp[1]=1
+ 遍历顺序：从前到后
+ 举例子推导尝试
  
### 2.2 爬楼梯

No.70 
+ dp数组： dp[i] 爬到i层有dp[i]种办法
+ 确定递推：dp[i-1]走一步 和dp[i-2]走两步 所以是dp[i] = dp[i-1] + dp[i-2]
+ 初始化：从一层开始考虑 dp[1]=1, dp[2]=2
+ 顺序：从前向后
+ 举例推导： 比如n=5： 1，2，3，5，8

### 2.3 爬楼梯开销

No.746
+ dp数组：dp[i] 爬到i层消耗的最小体力
+ 递推： dp[i] = min{dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]}
+ 初始化：dp[0]=0. dp[1]=0
+ 顺序：从前向后
+ 举例
  
### 2.4 不同路径

No.62
+ dp[i][j]: 到i，j的路径数量
+ 递推：dp[i][j] = dp[i-1][j] + dp[i][j-1]
+ 初始化：dp[0][1] = dp[1][0] = 1; 边缘都是1
+ 顺序：从左到右
+ 举例子：

### 2.5 不同路径（障碍版)

No.63
和普通版本相比 多了可能的障碍 无法通行
+ dp[i][j]: 依然是到i,j的路径数量
+ 递推：dp[i][j] = dp[i-1][j] + dp[i][j-1] &&input[i][j] != 1;
+ 初始化：依然初始化两条边 但是在遇到障碍后停下
+ 顺序：从左到右
+ 举例子：

# 动态规划

## 1. 概念

相比于贪心算法 DP每次的状态是由上个状态推导出来的，而贪心是局部最优解  
基础学习步骤：
+ 确定dp数组和意义
+ 确定递推公式
+ dp数组初始化
+ 确定遍历顺序
+ 推导dp数组

## 2. 例题推导

### 2.1 斐波那契

No.509
+ 确定dp数组： dp[i]第i个数
+ 递推公式：dp[i] = dp[i-1] + dp[i-2]
+ 初始化：dp[0]=0, dp[1]=1
+ 遍历顺序：从前到后
+ 举例子推导尝试
  
### 2.2 爬楼梯

No.70 
+ dp数组： dp[i] 爬到i层有dp[i]种办法
+ 确定递推：dp[i-1]走一步 和dp[i-2]走两步 所以是dp[i] = dp[i-1] + dp[i-2]
+ 初始化：从一层开始考虑 dp[1]=1, dp[2]=2
+ 顺序：从前向后
+ 举例推导： 比如n=5： 1，2，3，5，8

### 2.3 爬楼梯开销

No.746
+ dp数组：dp[i] 爬到i层消耗的最小体力
+ 递推： dp[i] = min{dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]}
+ 初始化：dp[0]=0. dp[1]=0
+ 顺序：从前向后
+ 举例
  
### 2.4 不同路径

No.62
+ dp[i][j]: 到i，j的路径数量
+ 递推：dp[i][j] = dp[i-1][j] + dp[i][j-1]
+ 初始化：dp[0][1] = dp[1][0] = 1; 边缘都是1
+ 顺序：从左到右
+ 举例子：

### 2.5 不同路径（障碍版)

No.63
和普通版本相比 多了可能的障碍 无法通行
+ dp[i][j]: 依然是到i,j的路径数量
+ 递推：dp[i][j] = dp[i-1][j] + dp[i][j-1] &&input[i][j] != 1;
+ 初始化：依然初始化两条边 但是在遇到障碍后停下
+ 顺序：从左到右
+ 举例子：

### 2.6 整数拆分

不是很会做
No.343
+ 确定dp含义 dp[i] 分拆数字i 能得到的最大乘积为dp[i];
+ 递推： 用j来遍历i，那么dp[i] 可以是j * i-j 也可以是j * dp[i-j] 所以dp[i] = max{dp[i], (i-j)*j, dp[i-j]*j} 
+ 初始化：从2开始初始化
+ 顺序：从小到大
+ 例子：

### 2.7 不同的二叉搜索树

No.96
我们可以画出n=3的情况 分别归类到n=2的情况的组合
dp[3]，就是 
元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
+ 元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
+ 元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
+ 元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

一共有i个节点
+ dp[i] 1到i为节点组成的二叉搜索树个数为dp[i]
+ dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
+ dp[0] = 1
+ 用j来遍历i的每一个数作为头节点的情况

### 2.8 零一背包问题

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。  
每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

我们依然使用dp步骤
+ dp[i][j] i代表物品 j代表背包的容量  那么dp[i][j]其实就是从下标[0-i]的物品任取
  放进容量为j的背包 价值的最大总和
+ 确定递推 其实每一次就是决定放不放新的物品i 然后取最大的情况
  dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);
+ 初始化 
  二维初始化 首先把只放一种东西的都初始化 其次把背包容量过小的都初始化
+ 遍历顺序 
  先物品再背包比较好 当然 都可以
+ 举例子

### 2.9 一维零一背包（滚动数组）


### 2.10 目标和问题

通过背包size来计算符合的nums

### 2.11 一和零



# 二叉树

## 1. 种类

满二叉树： 元素数量是2^k-1  
完全二叉树是最底层元素连续的二叉树 但不一定是满的  
二叉搜索树： logn 左小于中小于右
平衡二叉树： 左子树和右子树高度差不大于1  

## 2. 存储

### 2.1 链式存储

左指针 右指针分别指向下一个元素  

### 2.2 线性存储

按顺序编号存储 第i个元素左右节点分别是2i+1和2i+2  

## 3. 遍历

### 3.1 DFS

前中后序都是DFS，递归为主

### 3.2 BFS

一层一层遍历 层序遍历 迭代法  

### 3.3 遍历流程

递归访问： 先子树 后子节点

+ 前序遍历： 中左右
+ 中序遍历： 左中右
+ 后序遍历： 左右中

## 4. 定义

```CPP
    struct TreeNode{
        int val;
        TreeNode* left;
        TreeNode* right;
    

    TreeNode(t) : val(t), left(nullptr), right(nullptr) {}
    };
```

## 5. 递归遍历

例题 No.144 No.145 No.94

## 6. 迭代遍历

使用栈的思维 先进后出
前序： 先中后右然后左 这样可以先处理左
后序： 略微修改前序 返回翻转的数组
中序： 遍历和返回的顺序不同 首先一路向左遍历 而后逐渐添加右边的节点。

## 7. 统一访问

使用统一的办法访问前中后序遍历, 使用一个nullptr来标记某个节点已经访问过了
回溯如果再次碰到这个节点就push到result里

## 8. 层序遍历（BFS)

借助队列 实现一层一层的保存

No.102

## 9. 翻转二叉树

对每个子树都做翻转
No.226

## 10. 对称二叉树

同样既可以使用迭代也可以使用递归 递归的话就是左右中和右左中同时进行遍历 迭代的的话可以用队列一层一层装入需要比较的元素对比
No.100, No.101

## 11. 最大深度

节点深度：从根节点到该节点的最长简单路径边的条数或者节点数（取决于0还是1开始）
节点高度：从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于0还是1开始）

其中根节点的高度其实就是树的深度。我们用前序求深度 后序求高度

或者层序遍历直接求

No.104

